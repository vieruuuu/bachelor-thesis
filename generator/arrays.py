from lib import (
    python_array_to_cpp,
    python_complex_array_to_cpp,
    python_int_array_to_cpp,
)
from vars import *
import numpy as np
import scipy.stats
from librosa import sequence


def generate_arrays():
    array_type = "real_t"

    common_arrays = ""

    common_arrays += "#pragma once\n\n"
    common_arrays += "// generated by python script\n"
    common_arrays += '#include "ap_fixed.h"\n'
    common_arrays += '#include "common_types.hpp"\n'
    common_arrays += '#include "fft_common.hpp"\n'
    common_arrays += '#include "common_constants.generated.hpp"\n\n'

    ###
    thresholds = np.linspace(0, 1, N_THRESHOLDS + 1)

    common_arrays += f"constexpr unsigned int thresholds_size = n_thresholds + 1;\n"

    common_arrays += python_array_to_cpp(
        thresholds, "thresholds", array_type, "[thresholds_size]"
    )
    ###

    ###
    beta_cdf = scipy.stats.beta.cdf(
        thresholds, BETA_PARAMETER_FIRST, BETA_PARAMETER_SECOND
    )
    ###

    ###
    beta_probs = np.diff(beta_cdf)

    common_arrays += f"constexpr unsigned int beta_probs_size = n_thresholds;\n"

    common_arrays += python_array_to_cpp(
        beta_probs, "beta_probs", array_type, "[beta_probs_size]"
    )
    ###

    ###
    # p_init = np.zeros(2 * N_PITCH_BINS)
    # p_init[N_PITCH_BINS:] = 1 / N_PITCH_BINS

    # common_arrays += f"constexpr unsigned int p_init_size = n_pitch_bins * 2;\n"

    # common_arrays += python_array_to_cpp(p_init, "p_init", array_type, "[p_init_size]")
    ###

    ###
    freqs = FMIN * 2 ** (np.arange(N_PITCH_BINS) / (12 * N_BINS_PER_SEMITONE))

    common_arrays += f"constexpr unsigned int freqs_size = n_pitch_bins;\n"

    common_arrays += python_array_to_cpp(freqs, "freqs", array_type, "[freqs_size]")
    ###

    ###
    transition = sequence.transition_local(
        N_PITCH_BINS, TRANSITION_WIDTH, window="triangle", wrap=False
    )

    log_transition = np.where(transition > 0, np.log(transition), 0)

    log_transition_unique_vals, log_transition_inverse_idx = np.unique(
        log_transition, return_inverse=True
    )

    log_transition_index_map = log_transition_inverse_idx.reshape(log_transition.shape)

    common_arrays += python_array_to_cpp(
        log_transition_unique_vals,
        "log_transition_unique_vals",
        array_type,
        "[]",
    )

    common_arrays += python_int_array_to_cpp(
        log_transition_index_map,
        "log_transition_index_map",
        "index<length_of(log_transition_unique_vals)>",
        "[n_pitch_bins][n_pitch_bins]",
    )

    t_switch = sequence.transition_loop(2, 1 - SWITCH_PROB)

    log_t_switch = np.log(t_switch)

    common_arrays += python_array_to_cpp(
        log_t_switch, "log_t_switch", array_type, "[2][2]"
    )

    # transition = np.kron(t_switch, transition)

    # common_arrays += f"constexpr unsigned int transition_size = n_pitch_bins * 2;\n"

    # common_arrays += python_array_to_cpp(
    #     transition, "transition", array_type, "[transition_size][transition_size]"
    # )
    ###

    with open("../common/common_arrays.generated.hpp", "w") as cpp_file:
        cpp_file.write(common_arrays)
