from lib import (
    python_array_to_cpp,
    python_complex_array_to_cpp,
    python_int_array_to_cpp,
)
import librosa
from vars import *
import numpy as np
import scipy.stats
from librosa import sequence


def fixed_point_bit_width(min_val, max_val):
    # Use the max absolute value to determine integer bits
    max_abs_val = max(abs(min_val), abs(max_val))

    # Calculate required integer bits
    return int(np.ceil(np.log2(max_abs_val + 1)))


def generate_arrays():
    array_type = "real_t"

    common_arrays = ""

    common_arrays += "#pragma once\n\n"
    common_arrays += "// generated by python script\n"
    common_arrays += '#include "ap_fixed.h"\n'
    common_arrays += '#include "common_types.hpp"\n'
    common_arrays += '#include "common_constants.generated.hpp"\n\n'

    ###
    thresholds = np.linspace(0, 1, N_THRESHOLDS + 1)

    common_arrays += f"constexpr size_t thresholds_size = n_thresholds + 1;\n"

    common_arrays += python_array_to_cpp(
        thresholds, "thresholds", array_type, "[thresholds_size]"
    )
    ###

    ###
    beta_cdf = scipy.stats.beta.cdf(
        thresholds, BETA_PARAMETER_FIRST, BETA_PARAMETER_SECOND
    )
    ###

    ###
    beta_probs = np.diff(beta_cdf)

    common_arrays += f"constexpr size_t beta_probs_size = n_thresholds;\n"

    common_arrays += python_array_to_cpp(
        beta_probs, "beta_probs", array_type, "[beta_probs_size]"
    )

    beta_sums = np.concatenate(([0], np.cumsum(beta_probs[:N_THRESHOLDS])))

    common_arrays += python_array_to_cpp(
        beta_sums, "beta_sums", array_type, "[thresholds_size]"
    )

    ###

    ###
    transition = sequence.transition_local(
        N_PITCH_BINS, TRANSITION_WIDTH, window="triangle", wrap=False
    )

    log_transition = np.where(transition > 0, np.log(transition), 0)

    log_transition_unique_vals, log_transition_inverse_idx = np.unique(
        log_transition, return_inverse=True
    )

    log_transition_index_map = log_transition_inverse_idx.reshape(log_transition.shape)

    int_bits = fixed_point_bit_width(
        log_transition_index_map.min(), log_transition_index_map.max()
    )
    total_bits = 32

    common_arrays += python_array_to_cpp(
        log_transition_unique_vals,
        "log_transition_unique_vals",
        f"ap_fixed<{total_bits}, {int_bits}>",
        "[]",
    )

    common_arrays += python_int_array_to_cpp(
        log_transition_index_map,
        "log_transition_index_map",
        "index<length_of(log_transition_unique_vals)>",
        "[n_pitch_bins][n_pitch_bins]",
    )

    t_switch = sequence.transition_loop(2, 1 - SWITCH_PROB)

    log_t_switch = np.log(t_switch)

    common_arrays += python_array_to_cpp(
        log_t_switch, "log_t_switch", f"ap_fixed<{total_bits}, {int_bits}>", "[2][2]"
    )
    ###

    with open("../common/common_arrays.generated.hpp", "w") as cpp_file:
        cpp_file.write(common_arrays)
